PROPOSAL

Leading Question: Our goal in the project is to be able to organize information and create a search tool for storage and use.  Given a dataset of social networks from the Stanford Large Network Dataset Collection and using the pageRank algorithm, we aim to list that set in order of decreasing importance, based on the amount of nodes and edges each network has. The updated set would suggest how important each network is relative to each other and provide an ease in navigation and storage of information. The number of edges that each network has indicates how many interactions happen between people on that network, and so listing them in descending order displays where people go most to talk to each other. In the end, we want to create a tool that can be scaled for larger processes.

Dataset Acquisition and Processing: We will be using the Stanford Large Network Dataset Collection, specifically, its social networks dataset for Twitter. This is because it is a set that offers directed node connection that would make pagerank easier to implement. We will have a separate class that will process the edges(nodeId.edges - interactions between people) and the circles(nodeId.circles - the people themselves) described in the readme of the twitter data set. The class will be responsible for copying and creating new instances from the data set, one which we can manipulate to implement Page Rank. A BFS algorithm would be used to create a tree that organizes the nodes by number of edges. To handle potential errors, we plan to throw out incomplete data and potentially include that data in a separate text file meant for incorrect entries. 

Graph Algorithms: We plan on implementing the BFS and Dijkstra’s algorithm along with Page Rank and quicksort. We will organize the algorithms into two classes: one for creating and traversing the tree data from our Standord Twitter Dataset and the other for Page Rank traversal. When organizing the data from the Stanford Dataset we will create an object for each Twitter fuser and use BFS traversal to organize the objects in a tree corresponding with the directed edges. This use for the BFS traversal will allow us to quickly organize the information from the data set. Afterwards, when implementing the page rank class, we will use Dijkstra's algorithm to find the shortest length between the users and use this data to implement Page Rank. Our big O efficiency benchmark is to not exceed the time complexity of the longest algorithm of Dijkstra’s (O(n^2)). 